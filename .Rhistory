y2=matrix(0,ntsegm.ind*nind,b2)
info=matrix(0,ntsegm.ind*nind,2)
z2.true=z1.true=matrix(0,ntsegm.ind*nind,nbehavior)
z1.agg.true=array(NA,dim=c(ntsegm.ind*nind,b1,nbehavior))
z2.agg.true=array(NA,dim=c(ntsegm.ind*nind,b2,nbehavior))
for (i in 1:nind){
for (t in 1:ntsegm.ind){
z1=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z1.true[oo,]=z1
z2=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z2.true[oo,]=z1
for (k in 1:nbehavior){
z1.agg.true[oo,,k]=rmultinom(1,size=z1[k],prob=phi1[k,])
z2.agg.true[oo,,k]=rmultinom(1,size=z2[k],prob=phi2[k,])
}
info[oo,]=c(i,t)
oo=oo+1
}
}
y1=apply(z1.agg.true,1:2,sum)
y2=apply(z2.agg.true,1:2,sum)
colnames(y1)=paste0('y1','_',1:b1)
colnames(y2)=paste0('y2','_',1:b2)
colnames(info)=c('ind.id','tsegm')
fim=cbind(info,y1,y2)
image(cbind(y1,y2))
#export fake data
setwd('U:\\GIT_models\\git_LDA_behavior')
write.csv(fim,'fake data.csv',row.names=F)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(2)
setwd('U:\\GIT_models\\git_LDA_behavior')
source('LDA_behavior_function.R')
source('LDA_behavior_gibbs.R')
dat=read.csv('fake data.csv',as.is=T)
#prior
gamma1=0.1
alpha=0.1
#prepare for gibbs
ngibbs=1000
nburn=ngibbs/2
ind1=grep('y1',colnames(dat))
ind2=grep('y2',colnames(dat))
nmaxclust=10#max(length(ind1),length(ind2))-1
res=LDA_behavior_gibbs(dat=dat,gamma1=gamma1,alpha=alpha,
ngibbs=ngibbs,nmaxclust=nmaxclust,
nburn=nburn)
plot(res$loglikel[100:ngibbs],type='l')
compare=function(true1,estim1){
rango=range(c(true1,estim1))
plot(true1,estim1,ylim=rango,xlim=rango)
lines(rango,rango,col='red')
}
theta.estim=matrix(res$theta[ngibbs,],nrow(dat),nmaxclust)
boxplot(theta.estim)
library('MCMCpack')
set.seed(99)
#basic settings
ntsegm.ind=20 #number of time segments per individual
nind=40
nbehavior=5
b1=6
b2=10
nobs.tsegm=100 #number of observations per time segment
#get parameters
phi1.true=phi1=rdirichlet(nbehavior,alpha=rep(0.1,b1))
phi2.true=phi2=rdirichlet(nbehavior,alpha=rep(0.1,b2))
theta.true=theta=rdirichlet(ntsegm.ind*nind,alpha=rep(0.1,nbehavior))
#make sure that behaviors are not too similar
for (i in 1:(nbehavior-1)){
for (j in (i+1):nbehavior){
#phi1
tmp=phi1.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi1.true[j,]=rdirichlet(1,alpha=rep(0.5,b1))
#phi2
tmp=phi2.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi2.true[j,]=rdirichlet(1,alpha=rep(0.5,b2))
}
}
#look at these parameters
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi1.true[i,],type='h',main=i)
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi2.true[i,],type='h',main=i)
boxplot(theta)
apply(theta>0.95,2,mean)
#generate data
oo=1
y1=matrix(0,ntsegm.ind*nind,b1)
y2=matrix(0,ntsegm.ind*nind,b2)
info=matrix(0,ntsegm.ind*nind,2)
z2.true=z1.true=matrix(0,ntsegm.ind*nind,nbehavior)
z1.agg.true=array(NA,dim=c(ntsegm.ind*nind,b1,nbehavior))
z2.agg.true=array(NA,dim=c(ntsegm.ind*nind,b2,nbehavior))
for (i in 1:nind){
for (t in 1:ntsegm.ind){
z1=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z1.true[oo,]=z1
z2=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z2.true[oo,]=z1
for (k in 1:nbehavior){
z1.agg.true[oo,,k]=rmultinom(1,size=z1[k],prob=phi1[k,])
z2.agg.true[oo,,k]=rmultinom(1,size=z2[k],prob=phi2[k,])
}
info[oo,]=c(i,t)
oo=oo+1
}
}
y1=apply(z1.agg.true,1:2,sum)
y2=apply(z2.agg.true,1:2,sum)
colnames(y1)=paste0('y1','_',1:b1)
colnames(y2)=paste0('y2','_',1:b2)
colnames(info)=c('ind.id','tsegm')
fim=cbind(info,y1,y2)
image(cbind(y1,y2))
z1.tmp=apply(res$z1.agg,c(1,3),sum)[,1:5]
z2.tmp=apply(res$z2.agg,c(1,3),sum)[,1:5]
#find best order
ordem=numeric()
for (i in 1:ncol(z1.true)){
tmp=rep(NA,ncol(z1.true))
for (j in 1:ncol(z1.tmp)){
tmp[j]=cor(cbind(z1.tmp[,j],z1.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
ordem=c(ordem,ind)
}
# head(cbind(z1.tmp[,ordem],z1.true))
# head(cbind(z2.tmp[,ordem],z2.true))
compare(z1.true,z1.tmp[,ordem])
compare(z2.true,z2.tmp[,ordem])
compare(theta.true,theta.estim[,ordem])
ind1=grep('y1',colnames(dat))
phi1.estim=matrix(res$phi1[ngibbs,],nmaxclust,length(ind1))
compare(phi1.true,phi1.estim[ordem,])
ind2=grep('y2',colnames(dat))
phi2.estim=matrix(res$phi2[ngibbs,],nmaxclust,length(ind2))
compare(phi2.true,phi2.estim[ordem,])
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(101)
#basic settings
ntsegm.ind=20 #number of time segments per individual
nind=40
nbehavior=7
b1=6
b2=10
nobs.tsegm=100 #number of observations per time segment
#get parameters
phi1.true=phi1=rdirichlet(nbehavior,alpha=rep(0.1,b1))
phi2.true=phi2=rdirichlet(nbehavior,alpha=rep(0.1,b2))
theta.true=theta=rdirichlet(ntsegm.ind*nind,alpha=rep(0.1,nbehavior))
#make sure that behaviors are not too similar
for (i in 1:(nbehavior-1)){
for (j in (i+1):nbehavior){
#phi1
tmp=phi1.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi1.true[j,]=rdirichlet(1,alpha=rep(0.5,b1))
#phi2
tmp=phi2.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi2.true[j,]=rdirichlet(1,alpha=rep(0.5,b2))
}
}
#look at these parameters
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi1.true[i,],type='h',main=i)
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi2.true[i,],type='h',main=i)
boxplot(theta)
apply(theta>0.95,2,mean)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(101)
#basic settings
ntsegm.ind=20 #number of time segments per individual
nind=40
nbehavior=7
b1=6
b2=10
nobs.tsegm=100 #number of observations per time segment
#get parameters
phi1.true=phi1=rdirichlet(nbehavior,alpha=rep(0.1,b1))
phi2.true=phi2=rdirichlet(nbehavior,alpha=rep(0.1,b2))
theta.true=theta=rdirichlet(ntsegm.ind*nind,alpha=rep(0.1,nbehavior))
#make sure that behaviors are not too similar
for (i in 1:(nbehavior-1)){
for (j in (i+1):nbehavior){
#phi1
tmp=phi1.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi1.true[j,]=rdirichlet(1,alpha=rep(0.5,b1))
#phi2
tmp=phi2.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi2.true[j,]=rdirichlet(1,alpha=rep(0.5,b2))
}
}
#look at these parameters
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi1.true[i,],type='h',main=i)
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi2.true[i,],type='h',main=i)
boxplot(theta)
apply(theta>0.95,2,mean)
#generate data
oo=1
y1=matrix(0,ntsegm.ind*nind,b1)
y2=matrix(0,ntsegm.ind*nind,b2)
info=matrix(0,ntsegm.ind*nind,2)
z2.true=z1.true=matrix(0,ntsegm.ind*nind,nbehavior)
z1.agg.true=array(NA,dim=c(ntsegm.ind*nind,b1,nbehavior))
z2.agg.true=array(NA,dim=c(ntsegm.ind*nind,b2,nbehavior))
for (i in 1:nind){
for (t in 1:ntsegm.ind){
z1=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z1.true[oo,]=z1
z2=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z2.true[oo,]=z1
for (k in 1:nbehavior){
z1.agg.true[oo,,k]=rmultinom(1,size=z1[k],prob=phi1[k,])
z2.agg.true[oo,,k]=rmultinom(1,size=z2[k],prob=phi2[k,])
}
info[oo,]=c(i,t)
oo=oo+1
}
}
y1=apply(z1.agg.true,1:2,sum)
y2=apply(z2.agg.true,1:2,sum)
colnames(y1)=paste0('y1','_',1:b1)
colnames(y2)=paste0('y2','_',1:b2)
colnames(info)=c('ind.id','tsegm')
fim=cbind(info,y1,y2)
image(cbind(y1,y2))
#export fake data
setwd('U:\\GIT_models\\git_LDA_behavior')
write.csv(fim,'fake data.csv',row.names=F)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(2)
setwd('U:\\GIT_models\\git_LDA_behavior')
source('LDA_behavior_function.R')
source('LDA_behavior_gibbs.R')
dat=read.csv('fake data.csv',as.is=T)
#prior
gamma1=0.1
alpha=0.1
#prepare for gibbs
ngibbs=1000
nburn=ngibbs/2
ind1=grep('y1',colnames(dat))
ind2=grep('y2',colnames(dat))
nmaxclust=10#max(length(ind1),length(ind2))-1
res=LDA_behavior_gibbs(dat=dat,gamma1=gamma1,alpha=alpha,
ngibbs=ngibbs,nmaxclust=nmaxclust,
nburn=nburn)
plot(res$loglikel[100:ngibbs],type='l')
compare=function(true1,estim1){
rango=range(c(true1,estim1))
plot(true1,estim1,ylim=rango,xlim=rango)
lines(rango,rango,col='red')
}
theta.estim=matrix(res$theta[ngibbs,],nrow(dat),nmaxclust)
boxplot(theta.estim)
library('MCMCpack')
set.seed(101)
#basic settings
ntsegm.ind=20 #number of time segments per individual
nind=40
nbehavior=7
b1=6
b2=10
nobs.tsegm=100 #number of observations per time segment
#get parameters
phi1.true=phi1=rdirichlet(nbehavior,alpha=rep(0.1,b1))
phi2.true=phi2=rdirichlet(nbehavior,alpha=rep(0.1,b2))
theta.true=theta=rdirichlet(ntsegm.ind*nind,alpha=rep(0.1,nbehavior))
#make sure that behaviors are not too similar
for (i in 1:(nbehavior-1)){
for (j in (i+1):nbehavior){
#phi1
tmp=phi1.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi1.true[j,]=rdirichlet(1,alpha=rep(0.5,b1))
#phi2
tmp=phi2.true[c(i,j),]
tmp1=cor(t(tmp))[1,2]
if (tmp1>0.9) phi2.true[j,]=rdirichlet(1,alpha=rep(0.5,b2))
}
}
#look at these parameters
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi1.true[i,],type='h',main=i)
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi2.true[i,],type='h',main=i)
boxplot(theta)
apply(theta>0.95,2,mean)
#generate data
oo=1
y1=matrix(0,ntsegm.ind*nind,b1)
y2=matrix(0,ntsegm.ind*nind,b2)
info=matrix(0,ntsegm.ind*nind,2)
z2.true=z1.true=matrix(0,ntsegm.ind*nind,nbehavior)
z1.agg.true=array(NA,dim=c(ntsegm.ind*nind,b1,nbehavior))
z2.agg.true=array(NA,dim=c(ntsegm.ind*nind,b2,nbehavior))
for (i in 1:nind){
for (t in 1:ntsegm.ind){
z1=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z1.true[oo,]=z1
z2=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z2.true[oo,]=z1
for (k in 1:nbehavior){
z1.agg.true[oo,,k]=rmultinom(1,size=z1[k],prob=phi1[k,])
z2.agg.true[oo,,k]=rmultinom(1,size=z2[k],prob=phi2[k,])
}
info[oo,]=c(i,t)
oo=oo+1
}
}
y1=apply(z1.agg.true,1:2,sum)
y2=apply(z2.agg.true,1:2,sum)
colnames(y1)=paste0('y1','_',1:b1)
colnames(y2)=paste0('y2','_',1:b2)
colnames(info)=c('ind.id','tsegm')
fim=cbind(info,y1,y2)
image(cbind(y1,y2))
z1.tmp=apply(res$z1.agg,c(1,3),sum)[,1:7]
z2.tmp=apply(res$z2.agg,c(1,3),sum)[,1:7]
#find best order
ordem=numeric()
for (i in 1:ncol(z1.true)){
tmp=rep(NA,ncol(z1.true))
for (j in 1:ncol(z1.tmp)){
tmp[j]=cor(cbind(z1.tmp[,j],z1.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
ordem=c(ordem,ind)
}
# head(cbind(z1.tmp[,ordem],z1.true))
# head(cbind(z2.tmp[,ordem],z2.true))
compare(z1.true,z1.tmp[,ordem])
compare(z2.true,z2.tmp[,ordem])
compare(theta.true,theta.estim[,ordem])
ind1=grep('y1',colnames(dat))
phi1.estim=matrix(res$phi1[ngibbs,],nmaxclust,length(ind1))
compare(phi1.true,phi1.estim[ordem,])
ind2=grep('y2',colnames(dat))
phi2.estim=matrix(res$phi2[ngibbs,],nmaxclust,length(ind2))
compare(phi2.true,phi2.estim[ordem,])
library(microbenchmark)
microbenchmark(
z1.agg=sample.z1.agg(lphi1=log(phi1),ltheta=log(theta),y1=y1,
nobs=nobs,b1=b1,nbehav=nmaxclust),
z2.agg=sample.z2.agg(lphi2=log(phi2),ltheta=log(theta),y2=y2,
nobs=nobs,b2=b2,nbehav=nmaxclust),
v=sample.v(z1.agg=z1.agg,z2.agg=z2.agg,gamma1=gamma1,
nobs=nobs,nbehav=nmaxclust),
theta=get.theta(v=v,nbehav=nmaxclust,nobs=nobs),
phi1=sample.phi1(z1.agg=z1.agg,alpha=alpha,nbehav=nmaxclust,b1=b1),
phi2=sample.phi2(z2.agg=z2.agg,alpha=alpha,nbehav=nmaxclust,b2=b2)
)
library('MCMCpack')
set.seed(49)
#basic settings
ntsegm.ind=20 #number of time segments per individual
nind=40
#be careful with large nbehavior because it is easy to:
#- generate phi1 and phi2 in such a way that things are not clearly separable
#- generate theta in such a way that we don't have approx. pure time segments
nbehavior=6
b1=6
b2=10
nobs.tsegm=100 #number of observations per time segment
#get parameters
phi1=rdirichlet(nbehavior,alpha=rep(0.1,b1))
phi2=rdirichlet(nbehavior,alpha=rep(0.1,b2))
theta.true=theta=rdirichlet(ntsegm.ind*nind,alpha=rep(0.1,nbehavior))
phi1
phi2
#look at these parameters
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi1.true[i,],type='h',main=i)
#     tmp=phi1[c(i,j),]
#     tmp1=cor(t(tmp))[1,2]
#     if (tmp1>0.9) phi1[j,]=rdirichlet(1,alpha=rep(0.5,b1))
#
#     #phi2
#     tmp=phi2[c(i,j),]
#     tmp1=cor(t(tmp))[1,2]
#     if (tmp1>0.9) phi2[j,]=rdirichlet(1,alpha=rep(0.5,b2))
#   }
# }
phi1.true=phi1
phi2.true=phi2
#look at these parameters
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi1.true[i,],type='h',main=i)
par(mfrow=c(ceiling(nbehavior/2),2),mar=rep(1,4))
for (i in 1:nbehavior) plot(phi2.true[i,],type='h',main=i)
boxplot(theta)
apply(theta>0.95,2,mean)
#generate data
oo=1
y1=matrix(0,ntsegm.ind*nind,b1)
y2=matrix(0,ntsegm.ind*nind,b2)
info=matrix(0,ntsegm.ind*nind,2)
z2.true=z1.true=matrix(0,ntsegm.ind*nind,nbehavior)
z1.agg.true=array(NA,dim=c(ntsegm.ind*nind,b1,nbehavior))
z2.agg.true=array(NA,dim=c(ntsegm.ind*nind,b2,nbehavior))
for (i in 1:nind){
for (t in 1:ntsegm.ind){
z1=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z1.true[oo,]=z1
z2=rmultinom(1,size=nobs.tsegm,prob=theta[oo,])
z2.true[oo,]=z1
for (k in 1:nbehavior){
z1.agg.true[oo,,k]=rmultinom(1,size=z1[k],prob=phi1[k,])
z2.agg.true[oo,,k]=rmultinom(1,size=z2[k],prob=phi2[k,])
}
info[oo,]=c(i,t)
oo=oo+1
}
}
y1=apply(z1.agg.true,1:2,sum)
y2=apply(z2.agg.true,1:2,sum)
colnames(y1)=paste0('y1','_',1:b1)
colnames(y2)=paste0('y2','_',1:b2)
colnames(info)=c('ind.id','tsegm')
colnames(y1)
colnames(y2)
colnames(info)
fim=cbind(info,y1,y2)
image(cbind(y1,y2))
dev.off()
image(cbind(y1,y2))
library(microbenchmark)
microbenchmark(
#sample from FCD's
z1agg=SampleZ1Agg(nobs=nobs,b1=b1,y1=y1, nmaxclust=nmaxclust,
lphi1=log(phi1),ltheta=log(theta),zeroes=zeroes1),
z2agg=SampleZ2Agg(nobs=nobs,b2=b2,y2=y2, nmaxclust=nmaxclust,
lphi2=log(phi2),ltheta=log(theta),zeroes=zeroes2),
v=sample.v(z1.agg=z1.agg,z2.agg=z2.agg,gamma1=gamma1,
nobs=nobs,nbehav=nmaxclust),
theta=get.theta(v=v,nbehav=nmaxclust,nobs=nobs),
phi1=sample.phi1(z1.agg=z1.agg,alpha=alpha,nbehav=nmaxclust,b1=b1),
phi2=sample.phi2(z2.agg=z2.agg,alpha=alpha,nbehav=nmaxclust,b2=b2)
)
library('Rcpp')
set.seed(2)
source('LDA_behavior_function.R')
source('LDA_behavior_gibbs.R')
sourceCpp('aux1.cpp')
dat=read.csv('fake data.csv',as.is=T)
#prior
gamma1=0.1
alpha=0.1
#prepare for gibbs
ngibbs=1000
nburn=ngibbs/2
ind1=grep('y1',colnames(dat))
ind2=grep('y2',colnames(dat))
nmaxclust=10#max(length(ind1),length(ind2))-1
res=LDA_behavior_gibbs(dat=dat,gamma1=gamma1,alpha=alpha,
ngibbs=ngibbs,nmaxclust=nmaxclust,
nburn=nburn)
View(res)
microbenchmark(
#sample from FCD's
z1agg=SampleZ1Agg(nobs=nobs,b1=b1,y1=y1, nmaxclust=nmaxclust,
lphi1=log(phi1),ltheta=log(theta),zeroes=zeroes1),
z2agg=SampleZ2Agg(nobs=nobs,b2=b2,y2=y2, nmaxclust=nmaxclust,
lphi2=log(phi2),ltheta=log(theta),zeroes=zeroes2),
v=sample.v(z1.agg=z1.agg,z2.agg=z2.agg,gamma1=gamma1,
nobs=nobs,nbehav=nmaxclust),
theta=get.theta(v=v,nbehav=nmaxclust,nobs=nobs),
phi1=sample.phi1(z1.agg=z1.agg,alpha=alpha,nbehav=nmaxclust,b1=b1),
phi2=sample.phi2(z2.agg=z2.agg,alpha=alpha,nbehav=nmaxclust,b2=b2)
)
plot(res$loglikel[100:ngibbs],type='l')
compare=function(true1,estim1){
rango=range(c(true1,estim1))
plot(true1,estim1,ylim=rango,xlim=rango)
lines(rango,rango,col='red')
}
theta.estim=matrix(res$theta[ngibbs,],nrow(dat),nmaxclust)
boxplot(theta.estim)
z1.tmp=apply(res$z1.agg,c(1,3),sum)[,1:6]
z2.tmp=apply(res$z2.agg,c(1,3),sum)[,1:6]
#find best order
ordem=numeric()
for (i in 1:ncol(z1.true)){
tmp=rep(NA,ncol(z1.true))
for (j in 1:ncol(z1.tmp)){
tmp[j]=cor(cbind(z1.tmp[,j],z1.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
ordem=c(ordem,ind)
}
compare(z1.true,z1.tmp[,ordem])
compare(z2.true,z2.tmp[,ordem])
compare(theta.true,theta.estim[,ordem])
ind1=grep('y1',colnames(dat))
phi1.estim=matrix(res$phi1[ngibbs,],nmaxclust,length(ind1))
compare(phi1.true,phi1.estim[ordem,])
ind2=grep('y2',colnames(dat))
phi2.estim=matrix(res$phi2[ngibbs,],nmaxclust,length(ind2))
compare(phi2.true,phi2.estim[ordem,])
